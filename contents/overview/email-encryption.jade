:markdown
  ## Encryption

  Autonomail protects your email and keeps it private by using well-known industry-standard encryption techniques. But what do we 
  mean by encryption anyway? In this section we will try and explain how it works as simply as possible.

  ### The basics

  > Encryption is a process of preventing information from being seen by anyone other than the people for whom the information is intended.

  In the context of sending emails it means that when you send an email to somebody only you and the other 
  person should be able to read what's in that email. Even if somebody else intercepts the email whilst its en route to the recipient 
  they should not have the ability to read it.

  So how does encryption actually work in practice? Usually it involves taking the information you want to protect (let's call 
  this _plaintext_) and passing it through a mathematical algorithm to produce some complex-looking output (let's call this _ciphertext_). The 
  person receiving the message would then pass the ciphertext through the inverse of the original mathematical algorithm to reproduce the 
  original _plaintext_. 

  For example, let's say we have a simple encryption algorithm which shifts all letters forward by 1. Here is how the process would work:

  1. Alice wishes to send Bob the plaintext `hello`. 
  1. Alice passes this plaintext through the encryption algorithm _(shift each letter forward by 1)_ to produce the ciphertext `ifmmp`. 
  1. Alice then sends this ciphertext to Bob. 
  1. Bob passes the received ciphertext `ifmmp` through the decryption algorithm _(shift each letter back by 1)_ to get the original plaintext `hello`.

  The spy Eve is trying to eavesdrop on Alice and Bob's conversation. Eve knows what encryption algorithm Alice is 
  using to produce the ciphertext. So she can simply intercept the communication between Alice and Bob and run the same decryption 
  algorithm Bob is running to get the actual plaintext.

  To get around this Alice and Bob can improve their encryption algorithm. Instead of shifting letters forward by 1 why not shift by any 
  arbitrary number (let's call this the _encryption key_) which they both agree on beforehand? Let's say they both agree on a key of 3. 
  Here is how the process will look:

  1. Alice wishes to send Bob the plaintext `hello`. 
  1. Alice passes this plaintext through the encryption algorithm _(shift each letter forward `key` times)_ to produce the ciphertext `khoor`. 
  1. Alice then sends this ciphertext to Bob. 
  1. Bob passes the received ciphertext `khoor` through the decryption algorithm _(shift each letter back `key` times)_ to get the original plaintext `hello`.

  If Eve were to intercept the communication she would need to know the key in order to successfully decrypt the ciphertext. Since 
  she doesn't she then has to try and guess it, meaning she has try all the possibilities until she gets something which works - this is known 
  as a _brute force_ search. The level of security provided any good encryption process comes down to how long it would take to brute force the 
  key even if one has enormous computing power at hand to automate the task. Our simple encryption scheme above is too easy to break, so in 
  practice most encryption algorithms apply a far more complicated set of mathematical transformations, and use much larger key vlaues 
  (think numbers on the scale of 2^256 and higher!).

  We're finally left with one problem. How to ensure that Alice and Bob can agree on a key beforehand without 
  anyone else knowing? They can't really do this over the internet as this communication would itself require encryption to stop Eve from 
  knowing the key, which would leave them with the same problem of how to securely exchange keys. In an ideal world they would be able to 
  whisper it to each other in person, in a darkened sound and vibration-proof room. But this really isn't practically feasible. 
  Luckily there is a different class of encryption algorithms which can help us.

  ### Public key cryptography

  So far we have been talking about what are known as _symmetric_ encryption algorithms. This is where the same encryption key is used to 
  both encrypt the plaintext and decrypt the ciphertext. But as mentioned before, this leaves us with the problem of how to securely agree 
  on the key in the first place. 

  In so-called _asymmetric_ or _public key_ encryption algorithms, instead of 1 key there are usually 2. Both keys are 
  generated together from a mathematical algorithm such that they are mathematically related to each other. Here is the critical point: 
  **Data encrypted with one of the keys can only be decrypted with the other corresponding key, and vice versa.** Usually one of the keys is 
  designated as the _private_ key and is kept safe 
  and secure and never given out. The other key is designated as the _public_ key can is given out to the everyone who wishes to communicate 
  with you.

  Back to Alice, Bob and Eve, this might be the new process:

  1. Alice wishes to send Bob the plaintext `hello`. 
  1. Alice generates a public and private key pair.
  1. Alice sends her public key to Bob.
  1. Alice passes the plaintext through `encryption algorithm + her private key` to produce the ciphertext.
  1. Alice sends the ciphertext to Bob.
  1. Bob passes the recieved ciphertext through `decryption algorithm + Alice's public key` to get back the original plaintext `hello`.

  Let's say Eve intercepts step 3, where Alice sends her public key to Bob. If Eve modifies the public key before it reaches the Bob her 
  modification will be detected later on, as Bob will not be able to decrypt the messages sent to him by Alice. Since Eve does not know 
  Alice's private key she cannot send fake messages to Bob pretending that they're from Alice. However Eve still knows Alice's public key, 
  which means she can still decrypt the messages Alice sends out. So to be fully private we need to create a pair of keys for Bob too:

  1. Alice wishes to send Bob the plaintext `hello`. 
  1. Alice generates a public and private key pair.
  1. Alice sends her public key to Bob.
  1. Bob generates a public and private key pair.
  1. Bob sends his public key to Alice.
  1. Alice passes the plaintext through `encryption algorithm + Bob's public key` to produce the ciphertext.
  1. Alice sends the ciphertext to Bob.
  1. Bob passes the recieved ciphertext through `decryption algorithm + his private key` to get back the original plaintext `hello`.

  Now Eve can no longer decrypt the message sent from Alice to Bob because she does not know Bob's private key. She also cannot decrypt 
  messages sent from Bob back to Alice since she does not know Alice's private key. However she can still pretend to be either party and 
  send messages to the other party because she knows their respective public keys:

  1. Alice wishes to send Bob the plaintext `hello`. 
  1. Alice generates a public and private key pair.
  1. Alice sends her public key to Bob.
  1. Bob generates a public and private key pair.
  1. Bob sends his public key to Alice, but Eve eavesdrops on this.
  1. Eve now passes some plaintext through `encryption algorithm + Bob's public key` to produce the ciphertext.
  1. Eve sends the ciphertext to Bob.
  1. Bob passes the ciphertext through `encryption algorithm + his private key` to produce the plaintext.
  1. At this point Bob thinks Alice sent him the message, without realizing that it was actually Eve. 
  1. Eve does an evil laugh.

  How can we prevent Eve from being able to do this? we need a way for Bob to verify that the message did indeed come from Alice and that 
  it hasn't been tampered with. This is where _digital signatures_ come into play.

  ### Digital signatures

  A digital signatures in an email is like a hand-written signature in a letter except that it does a lot more. It allows the receiver to 
  verify that the email content hasn't been tampered and that the email is actually from the person who signed it. Unlike hand-written 
  signatures, digital ones are unique not only to the person signing but also to the document being signed. Meaning if that the signed 
  document is modified even slightly then the signature verification will fail. Most importantly, digital signatures are nearly impossible 
  to counterfeit (as hard as brute-forcing an encryption key).

  Digital signatures are generated by running a piece of data through a cryptographic _hashing algorithm_ - this performs a 
  mathematical calculation across the input and generates a number which uniquely represents that input data. The hashing algorithm can also 
  be a fed an encryption key, which essentially further customized the signature output value such that its unique to that content and key 
  combination.

  So how might we make digital signatures work with our public-key email encryption system above?

  1. Alice wishes to send Bob the plaintext `hello`. 
  1. Alice generates a public and private key pair.
  1. Alice sends her public key to Bob.
  1. Bob generates a public and private key pair.
  1. Bob sends his public key to Alice, but Eve eavesdrops on this.
  1. Alice passes the plaintext through a `hashing algorithm` and encrypts the result with her private key.
  1. Alice passes the plaintext and signature through `encryption algorithm + Bob's public key` to produce the ciphertext.
  1. Alice sends the ciphertext to Bob.
  1. Bob passes the received ciphertext through `decryption algorithm + his private key` to produce the plaintext and signature.
  1. Bob passes the plaintext through the `hasing algorithm` and checks the received signature using Alice's public key.
  1. If signature matches then Bob can be sure that the message is from Alice and that it hasn't been modified.

  An important pont to note is that **a message does not need to be encrypted in order to be digitally signed**. Thus, if you email somebody 
  who does not have email encrpytion enabled in their email client you can still digitall sign your messages to them so that they can 
  at least verify the authenticity and integriy of the message. 

  ### PGP

  Autonomail uses the Pretty-Good-Privacy (PGP) system for encrypting and digitally signing email messages. PGP's process is rougly similar to 
  the encryption process we've outlined above with a few differences for efficiency purposes. All PGP implemenations follow the well 
  established [OpenPGP standard](http://tools.ietf.org/html/rfc4880).

  ### Autonomail

  Now that you have a basic understanding of encryption and digital signatures in the context of email you know how Autonomail works. A few 
  final points to keep in mind:

  In order for two people to communicate with each other in private without anybody eavesdropping they both need to generate a key pair 
  and exchange public keys with each other. **Autonomail automatically generates a key pair for you when you first sign up.**

  Autonomail stores your generated keys within a _keychain_. This local storage system also contains the public keys for people you have 
  communicated with. When a new public key gets sent to you Autonomail will prompt you to 'import' this new key into your keychain. Your 
  keychain itself is kept secure within your [secure datastore](/#docs/client/secure-data). 

  True privacy can only be achieved if both parties know each other's public keys. **Autonomail automatically encrypts all outgoing 
  email messages where you have the recipient's public key**.

  It is essential that when receiving someone's public key for the first time you double check to make 
  sure that it is indeed their public key and not someone else's. **Autonomail will ask for confirmation before importing someone else's 
  public key into your local keychain**.

  Finally, not everyone you communicate with will have encryption enabled. But an email message can be digitally signed even if it isn't 
  encrypted. **Autonomail automatically digitally signs all outgoing emails** so 
  that recipients can verify the integrity and authenticity of messages you send.


  ### Technical details

  The specific PGP implementation we use is an [Emcripten port of Gnu Privacy Guard (GnuPG) 2](). The 
  random data generator is seeded with output from the [Fortuna PRNG]() implementation in [SJCL](http://bitwiseshiftleft.github.io/sjcl/). 
  The entropy sources for this include 
  `window.crypto.getRandomValues()`, mouse movements and keyboard strokes.





